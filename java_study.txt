━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━JAVA 1━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1일차 부터 복습해보자
프로그래밍이란? 사용자와 컴퓨터가 대화할수있게 하는것

프로그래밍 언어중 자바는 입문이 쉽고 사용빈도가 많다.
(@특히 많이 쓰이는 프로그램중에선 안드로이드 앱을 만드는 안드로이드 스튜디오, 국내 정부가 제시하는 프로그램들.

자바의 장점? JVM (Java Virtual Machine)
-Class Loader : 클래스를 메모리에 적재한다
-Runtime Data Areas : RAM 영역 관리
-Execution Engine : 소스코드를 읽고 실행한다.

JRE (Java Runtime Environment) : JVM을 실행하는 부분
JVM에서 실행할때 필요한 라이브러리+ 기타파일들을 갖고 있음.

JDK (Java Development Kit)
:JRE 외에 필요한 도구들을 갖고있다.

Eclips :통합 IDE (자바 컴파일러 포함)

컴파일? 소스코드를 컴퓨터가 이해할수 있게 변환해주는것
컴파일러? 컴파일 행위를 하는것

※개발자들과의 약속 -클래스는 항상 대문자로 쓸것!
프로젝트 - 패키지 - 클래스 - 메소드 -소스코드 작성
(*메인 메소드가 명령 시작하는 지점)

주석? 설명글 (// 한줄 , /* 범위 */)

변수란?(Variable) 사전적의미= 임의의 값을 가질수 있는 문자를 뜻함.
( *상수란? 늘 같은 값을 가지는 수)

예를 들면 int x = 10; 
int는 자료형 / x는 변수명 / 10은 값 / 세미콜론은 항상 붙여줘야 함

자료형엔 정수형int(4byte), 실수형flaot(4)/double(8) , 문자형char(2), 문자열String(??)
이중 기본 자료형은 int flaot double char

※변수 선언시 같은이름 중복은 불가. 공백 불가. 초기화 필수. 
변수명 지을땐 숫자는 맨앞에 사용불가. 특문(_제외) 사용불가. 명사로 사용. 뜻이명확. 되도록 소문자.
두가지 이상 명사가 사용될땐 카멜표기법 (strName) 또는 언더바(str_name)

변수 사용 목적 = 1. 반복 값의 쉬운 관리 2. 값에 의미부여
변수 초기화시 int = 0; float =0.0F; double = 0.0(D); char = 0; String = null; (null사용시 메모리할당안함)

System.out.print() 
System.out.println()  라인변경
System.out.printf() 서식문자("%d %s", number ,msg); 일때 %뒤의 값은 자료형에 따른다
 
%d 정수, %f 실수(flaot), %c 문자,%s 문자열, %o정수(8진수octal),%x정수(16진수 hexadecimal), %X 16진수 알파벳대문자표기

-줄바꿈 \n  ex) System.out.print("안녕 \n 하세요")


자동 형변환
정수+정수 = 정수 / 정수+실수 = 실수
문자+정수 = 정수 (문자가 아스키코드표에 의해 10진수로 변환되서 출력)

강제(수동) 형변환
문자열을 정수로 Integer.parseInt("문자열");
문자열을 실수로 Double.parseDouble("문자열");
문자열을 문자로 문자열.charAt(번호); // 번호는 0부터 시작
다른값을 문자열로 "" + 다른값;

*숫자사이에 +는 연산 문자열 앞뒤로 오면 연결

입력 메소드 - 입력상태 : 커서가 깜빡이고 있는 상태,, 입력받기전 사용자가 어떤 값을 입력할디 먼저 알려줌.
입력 클래스 (Scanner) Scanner sc = new Scanner(System.in);
문자열 입력 메소드 sc.next(); 사용자가 입력한 문자열 값을 반환.
※사용자가 공백이나 엔터를 입력하면 구분점으로 판단.
sc.nextLine(); 엔터로 구분점 판단


연산자  - 기능이 있는 특수문자, 특정언어
연산자 우선순위
최우선연산자 - 단항연산자 - 산술연산자 - 쉬프트연산자 - 관계연산자 - 논리연산자 - 삼항연산자 - 대입연산자

비트(bit) 연산 (bit=> 2진수)
ex) 11의 2진수는 1011 , 10의 2진수는 1010
논리 연산자	 (& and 논리곱) (\ or 논리합) (^ xor 배타논리합)
단항 연산자	 ~not 논리 부정 ※ ~a = -a-1 공식입니다.외우세요 ex) ~11 = -12
부호비트  가장 앞에 있는 비트가 부호비트(최좌측, 최상위) 0-양수 , 1- 음수
쉬프트 연산자 <<(좌시프트) >>(우시프트)
a<<b a를 b만큼 좌로 비트 이동 (비트연산 제한에 따라 커질수도 있음)
a>>b a를 b만큼 우로 비트 이동 (작아질수밖에 없음)
빈자리는 0으로 채워짐 (음수는 1로 채워짐) 비트수를 넘어가면 자동으로 잘림.
ex> 4비트 연산에서 11 <<1 는 1011<<1이라보고  0110 은 6이다. 11>>1은 1011>>1이라보고 0101은 5이다.
	1011<<2 는 1100 이고 1100은 12다. 1011>>2 는0010이고 0010은 2다.

(※빅데이터 AI 에서는 쉬프트 연산을 먼저 시켜주면 컴퓨터 데이터처리가 빠르다.)

조건식 - 결과가 참또는 거짓으로 나오는식
논리형(데이터 타입 종류) Java에서는 참을 true(1) 거짓을 false(0) 이라 표현 (괄호는 정수표현)
	이값을 담을수 있는 타입은 boolean 과 1byte
관계연산자 ==같다, !=같지않다 ,  > 초과,  <미만 , >=이상 , <=이하
논리연산자 && (and) 두조건식모두 참이면 참  , || (or) 두 조건식 하나라도 참이면 참
단항연산자 !NOT : !A  (A조건식이 참이면 거짓으로, 거짓이면 참으로 변경)
삼항연산자 ( ? : ) 조건식 ? 참일때 값 : 거짓일때 값;
int result = 0; 초기화하고 result = 7==7? 7777 : 6666; 이 문장에 result출력 참인 777 출력됨
※삼항 연산자를 사용한 문장은 전체를 값으로 볼줄 알아야하며, 결과 값을 '변수' 에 넣어줘야함. 위엔 result라는변수사용했쥬



제어문- 조건문과 반복문
조건문 if문과 switch문 ( 하나의 변수에 여러개의 값이 담기는 상황에서쓰임)
if(조건식a){a가참일때실행문} else if(조건식b){b가참일때실행문} else{a와b가 거짓일때 실행문}
조건식 a가 참이면 뒤에 bc는 검사 안함
switch(변수명){case값1 : 1실행문; break; case값2 : 2실행문; break; case값3 : 3실행문; break;
default: 실행할 문장; } (break; 이 없으면 이하의 값이 다 출력. defualt 선택지 없는값}
※if 문은 다양한 관계 연산자와 논리연산자를 사용할때 쓰고, 비교할땐 switch문을 씁니다

반복문
대입연산자 (누적연산자, 복합 대입 연산자)
int money = 10000; (1000을 추가한다?) money = money+1000; 로 쓸수 있지만  money += 1000; 이렇게 쓸수있다. -=도 마찬가지
증감 연산자 (++ , --) 1씩 증감
int data = 10;(1씩추가한다?) data= data+1; → data+=1; →data++;
전위형 ++data; 해당줄부터 적용. 후위형 data++; 다음줄부터 적용
for문과 while문 ( while문은 초기식 증감식 없음)
for(초기식; 조건식; 증감식;){반복할 문장} 
기타 연산자 - break; 해당 중괄호를 탈출 / continue; 다음 반복으로 넘어감 *밑의 문장을 실행시키지 않기 위해 사용함*
이중 for문 → for(int i =0; i<10;i++){ i출력 :  for(int j =0; j<10; j++){j출력}} 하면 0:0123456789 ~ 9:0123456789 까지 출력됨
while(조건식){실행할 문장;}  →선평가후 실행 (조건이 너야? 오키 문장실행!)
do while문 do{실행할 문장;}while(조건식); →선실행후 평가 (일단 문장진행해! 초이스 다음에 받고 가버렷!)


배열 (Array) - 같은 자료형인 저장공간의 나열
동일한 자료형(data type)의 데이터를 연속된 공간에서 저장하기  위한 자료구조(그룹화하여 묶어준다고 생각하면 됨)
연관된 데이터를 저장하기 위한 변수의 선언을 줄여주며, 반복문 등을 이용하여 계산과 같은 과정을 쉽게 처리 할 수 있다.
배열 선언 
1.자료형[] 배열이름={값1,값2,값3,...}; 값을 미리 알고있을때 ex) int [] number = {}
2.자료형[]배열이름 = new자료형[갯수]; 크기만 알고있을때
*new  -> heap메모리에 할당하는 명령어. (메모리들어간다 입벌려라!)
*순서는 인덱스(index)라 표현, 0부터 시작함.
int[] arrNum = new int[5]; //배열선언 // arrNum[0] = 10; //저장공간// arrNum[1] +9 ; //값 // arrNum[3] = arrNum[0]-3; //저장공간=값
*배열명을 출력했을때 나오는 텍스트는 type@주소값
*length 배열선언하면 length가 자동으로 할당. 할당한 배열의 길이를 갖고있다. 배열명.length로 사용함
2차원 배열 : 배열 안의 배열
자료형[][] 배열이름 = new자료형[행][열]; // 자료형[][]배열이름 = {{값1,값2,..},{값1,값2,..},{값1,값2,..},{값1,값2,..}};
(★배열관련하여 Generic을 배우고 다시 ArrayList를 배우며 다시 상기시킬텐데 이때 또한 헷갈리지 않게 연습 및 반복이 필요)

메소드? 이름뒤에 소괄호가 온다. 단, 키워드()는 메소드가 아니다.  for(),if(),switch(),while(),do~while ..은 메소드가 아니다.
특정 기능을 하는 소스코드 집합 예를들면 main() 같은 소괄호는 메인메소드라 불린다.
메소드 선언 예시!  ②메소드 이름 생각 ▶ ③매개변수 생각 ▶①리턴값작성 ▶④실행문작성 ▶⑤리턴작성
①int	 ②add	(③int num1, int num2)    {④int result = num1 + num2;   ⑤return result;}
(1)리턴타입 (2)메소드명(자료형 (3)매개변수명, ....)  {(4)실행할 소스코드; 	    (5)return 리턴값; }
(※1,4,5는 생략이 가능함. 2는 동사로 작성해야함. 3은생략가능하지만 외부로부터 데이터를 받을수 없음. 외부에서전달받을 값의 타입과 개수를 설정. 예를들면 int abc(int a, String b , char c){}
(※메소드 선언시 주의사항은 선언은 반드시 밖에서 , 사용은 반드시 안에서!)
메소드 사용 = 메소드명(값1,값2,...); 매개변수의 타입과 선언된 순서에 맞춰 알맞는값 전달.
리턴타입이 void라면 실행 메소드이며 값으로 봐서는 안된다. 리턴이 있다면 해당 부분을 통째로 볼줄 알아야함.
메소드를 사용하는 목적 = 1.재사용의 목적 (*특정성을 부여해서는 안됨) 2.소스코드의 간결화 
return 사용해야 할 때? 메소드안에서 모든 작업이 끝나지 않았을때, 사용하는 부분에 결과값을 전달해야 할때.
return 사용하지 않을때? 메소드 안에서 모든작업이 끝났을때, 사용하는 부분에 결과값을 전달할 필요가 없을때.
Java Method 사용시 매개변수가 기본자료형이면, 원데이터는 변경되지 않는다! (Pass by value)
Java Method 사용시 매개변수가 주소값이면 , 원데이터가 변경된다. (Pass by Reference)

폰 노이만 아키텍쳐란?! (존 폰노이만) (아키텍쳐란 컴퓨터설계구조의하나. 개발자입장에서는 하드웨어구조 뜻함)
병목현상(병의윗부분처럼좁은통로로지연되는현상)이 일어나지만 대체할만한 구조가 사실상 없음 (cpu=중앙처리장치  ram ,memory =주기억장치 rom=보조기억장치 / os =운영체제

Java는 객체 지향언어이자 선두주자이다!  (객체지향 <|> 절차지향)
객체 지향 언어? 우리가 실생활에서 보고 느끼는 모든것 ->객체(Object)->이 객체를 소스코드에 적용해서 직관적으로 프로그램개발
장점: 직관적(쉽고 접근성이 좋아서 유지보수good), 코드 재사용 유리, 협업에 유리(대형프로젝트적합)
단점: 설계 과정이 오래걸림, 처리속도가 상대적으로느림. 객체가 많으면 용량이 커질수있음.
★객체 지향의 특징 4가지 ! = 추상화, 캡슐화(은닉화) , 상속 ,다형성  // 5가지라면??(클래스+인스턴스(객체))

CLASS : 객체를 생성하기 위한 설계도(정의서) ->유사한 특징을 지닌 개겣들의 속성, 기능을 묶어 놓는 집합(체)
(@클래스를 바로 쓸수 없다. 객체를 생성해야 사용 가능하다!(우리가 항상 메소드를 입력하기위해선 새클래스를 만들었다는걸 상기하라)
강아지 클래스생성 Dog happy = new Dog(); 객체 생성후 happy.name="해피"; happy.age=2; 
★ new : Class를 Object로 만들고 메모리에 할당함. 이것을 인스턴스화! 객체화! 라고 한다. 변수들은 초기화됨
구성요소
- 속성(Attribute) - > 변수(기본 자료형, 배열, 클래스)
- 기능 (Method)
- 생성자(Constructor) class를 객체로 만들어주는 메소드. 클래스명() 을 생성자라고 함. 
생성자는 리턴을 사용할수 없음. 생성자를 호출하면 객체 값들이 초기화됨.
★ 생성자는 생략되어있다. 하지만 호출할때 생성자를 호출함. Dog(){} 생성자임. 생성자는heap에 주소값을 메모리에 올려주는 역할.
★ 리턴타입(void)안씀. 클래스 이름과 똑같다.
@클래스변수, 지역변수 , 매개변수 헷갈리면 안됨.
(클래스 변수는 String name;같이 Dog클래스에서 선언해준변수 , 지역변수는 중괄호안에서 사용가능한 말그대로지역에서 사용가능변수. 매개변수는 메소드에 넣어 매개가 되는 변수(happy.eat("땅콩"))<땅콩이)
(지역변수는 초기화를 해줘야하는 반면, 클래스변수(인스턴스변수,멤버변수)들은 초기화가 된다. )


★클래스는 추상적인 개념이고, 필드에 접근하기 위해서는 구체적인 개념이 필요! 이 개념을 객체라고 부르고 인스턴스 변수라고도 부른다.
★메소드 오버로딩  : 매개변수의 개수 혹은 타입이 서로 다르면 같은 이름의 메소드를 선언 할 수 있음
this의 활용. 변수가 헷갈리지 않게하기 위함. 위에 값을 가져온다고 보면됨.
	Dog(int age){
		this.age = age;
	}  //생성자에도 매개변수 넣을수 있고, 생성자에도 오버로딩가능하다.
	//매개변수를 직관적으로 써야할때가 있기 때문에 int age로 매개변수를 넣어야
	

★static - (고정적인 의미: 정적변수)(static int data = 33; 다른클래스에서 객체화없이 불러올수있음.but 메모리 효율 떨어짐. 메모리구조에서 데이터영역에 바로 할당된다고 보면 됨.)
변수, 메소드를 데이터 영역에 할당 시켜주는 키워드 / 변수 타입앞에 메소드의 리턴타입 앞에 표기함.
데이터 영역에 들어가는 변수나 메소드는 프로그램이 종료 될 때까지 유효하며, 모든 클래스에서 사용할수 있다.
무분별하게 static 사용시 메모리 효율이 극히 떨어짐. - Util관련 메소드나 변수에만 사용. 모든클래스에서 사용가능한 부가 메소드들, 필드들만 사용.
static변수들은 new로 초기화 안됨. 프로그램 종료까지 이어지기 떄문에 재시작해야 초기화 가능함.
(결국 System.out.print도 보면 out의 오버라이딩값을 찾아보면 static이라 객체화를 따로 안하쥬? 전체적으로 사용하는 고정친구들만 static써줘야합니다)
★ 변수 (변하는 값, 수) <|> 상수 (고정된 값)  |||   final 변수명을 보통 대문자+_로 구성. 파이=3.14변환불가 합니다
final double PI = 3.14; 상수선언(파이널 키워드로)// 상수는 고정된 값이다! 대문자 표기로 약속

상속(Inheritance)
1. 기존에 선언된 클래스의 필드를 새롭게 선언하는 클래스의 필드에서 사용하고 싶을때
2. 여러클래스를 선언 할 때 공통 필드가 많다면, 부모클래스를 선언하고 공통필드를 선언후 여러 클래스들에게 상속해주기 위함.
3. 상하 관계, 포함 관계가 있을 시 사용

상속하는 법 extends  class A{클래스변수및 메소드}  // class B extends A {B고유 필드 및 메소드}
A : 부모클래스 , 슈퍼클래스, 상위클래스//  B : 자식클래스, 서브클래스, 하위클래스
★ 상속단계 ▶  A->B->C->D->E ▶ A,B->C(다중상속불가능)(자바에서 불가능, 다른언어중에 가능한 언어있음)
★ this. 자기자신가르킴 // super. 부모클래스가르킴

다형성
1. Overloading오버로딩 (매개변수에 따라)
2. Overriding오버라이딩 (메소드 재정의 , 상속받아서 재정의한다고 보면됨. 덮어쓰기)
상속중 = 부모에 있는 메소드가 자식에서 수정이 필요하다면, 똑같은 이름으로 자식에서 재정의 해준다. @어노테이션을 사용하여 override라고 표현해야함

형변환
up casting : 부모타입에 ㅈ식값을 넣는 형 변환		A a = new B();
down casting : ★ 자식 타입에 부모값을 넣으면 오류	B b = (B)new A(); //오류남//
	└자식 타입 up casting 된 객체를 넣어 형변환 	자식클래스명 자식객체명 = (자식클래스명)업캐스팅된객체명;
A a = new B(); 이렇게 업캐스팅 한다음에  B b = (B)a;  다운캐스팅을 이어서 작성하면 동작함. 오픈소스를 가져올때 casting 하는 경우가 많음!!!


---------------------------------------------------
implements  =interface 상속 무조건 상속받아
anonymous _ 익명클래스를 이용
필드의개념 ? 필드=변수이며, 선언위치에 따라 구분. 멤버변수에도 접근제한자를 사용가능but, public 아닌 private사용
클래스 변수(클래스영역에 static키워드를 갖고, 객체화 안하고 바로사용가능) 
멤버변수 - 클래스 영역에 선언하며, 메소드 바깥에 선언했기떄문에 클랠스 내 모든 메소드에서 사용가능
지역변수 - 클래스 영역이 아닌 메소드, 생성자, 초기화 블럭 내부에 선언하며 속한 메소드에서 사용가능
(이해가 안갔을땐 위에 다시 검색해봐!!)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━JAVA 2━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
대단원 Class , Collection , API , Thread , Stream&Buffer



접근 권한 제어자 (Access modifier)  or 제한자
필드나 메소드 선언시 다른 곳에서 접근 여부를 결정할수 있도록 접근에 권한을 제어하는 문법-> OOP중 캡슐화(은닉화)를 실현하기위한 도구
default (생략) : 다른 패키지에서 접근할수 없음.
public : 모든 패키지에서 접근 가능. ( 패키지 밖에서 import하여 사용가능. )
protected : 다른 패키지에서 접근할수 없음. 자식이면 가능
private : 다른 클래스에서 접근 불가
Method로 접근(Getter / Setter)
필드의 자료형 앞, 메소드 리턴타입 앞에 작성해야함.
class의 캡슐화하기 위함이며, 접근 제한이 필요한 이유는 관리자와 사용자의 분리정도로 예시를 들수 있다. (사용자가 관리자의 필드까지 접근하여 메소드를 바꾼다면 큰일이 일어날것)

추상 클래스 (Abstract Method) - {}바디가 존재하지 않는 메소드
추상 메소드 (Abstract Class) - 불완전한 클래스, 미완성 설계도, 추상메소드를 한개 이상 포함하는 클래스
->상속을 통해서 자식 클래스에서 추상메소드 완성을 유도하는 클래스. [추상적 내용만 정의(메소드이름,매개변수,리턴타입)하고 구체적내용은 하위클래스에서 재정의하도록 설계된클래스]
★ 추상 클래스는 객체화(인스턴스화)가 불가능하다! 
추상 클래스 선언 abstract class 추상클래스명{ abstract 리턴타입 추상메소드명(매개변수..);} 
★추상 메소드는 자식 클래스에서 강제적으로 반드시 ★재정의★ 해야함.

사용목적 1. 공통된 필드와 메소드를 통일할 목적- 필드와 메소드 이름을 통일하여 유지보수성을 높이고 통일성 유지
	2. 실제 클래스 구현시, 시간 절약 - 강제로 주어지는 필드와 메소드를 가지고 기능 작성에만 집중가능
	★3. 규격에 맞는 실체 클래스 구현 - 협업시 유리 - 기본 가이드 제공.

인터페이스 (interface) :기본 설계도 . 추상클래스를 고도화 시킨 문법.
★반드시 추상 메소드와 상수만 선언해야 한다. 극단적으로 동일한 목적하에 동일한 기능을 보장하기 위해 사용!!
클래스에서 인터페이스를 지정받을때는 implements를 사용!  클래스에서는 인터페이스가 갖고있는 추상메소드를 반드시 ★재정의해야한다
ex > public class Print2Thread implements Runnable{}  // Runnable interface를 재정의 해서 Print2Thread라는 클래스의 메소드에 @override 하여 재정의하고 사용해야함
★상속과 인터페이스 지정 같이 사용가능 ★자바는 다중상속 불가능하지만 인터페이스는 여러개 지정가능!!
(defualt를 이용하여 일반메소드를 쓸수 있긴함.)

추상클래스 vs 인터페이스? 쉽게 보자
1. 추상클래스는 추상메소드 1개 이상만 있으면 됨. (일반메소드 포함가능)
	└인터페이스는 무조건 추상 메소드만! 있어야 함.
2. 추상클래스는 다중상속 불가
인터페이스는 여러게 지정 가능

★이너 클래스 (Inner Class) 내부클래스 - 클래스 내부에 클래스를 선언 하는 것
상속을 받지 않고서도 외부 클래스 필드 접근을 위해 사용한다.
내부 클래스의 필드를 사용하기 위해서는 외부 클래스 객체에서 내부클래스를 객체화 해야한다
Out out = new Out();
Out.In.in  = out.new In();
이너 클래스를 사용하는 목적은 1. 캡슐화 2. 상속처럼 사용.
캡슐화- (1)외부 클래스가 없다면 내부클래스도 존재할수 없음.(2)다른클래스에서 접근을 막고자 사용.(3)외부클래스 객체화 없이는 사용불가. (4)내부클래스를 숨기기위함.
상속 - 외부클래스의 필드를 마치 내것처럼 사용하기 위함.
★GUI (Graphic User Interface) 개발시 많이 사용함.

익명 클래스 (Anonymous Class) - 이름이없는 클래스, 일회성으로 사용하기 위한 클래스! ->선언과 동시에 사용하는 클래스
클래스 내에 인터페이스를 매개변수로 받는 Method가 있는 경우, 해당 클래스 객체화후 메소드 사용시 인터페이스에 있는 추상 메소드를 재정의 해주는 방식 => 자동완성 사용해서 완성!
★안드로이드나 UI이벤트 처리시에 자주 쓰이는 문법
익명클래스는 선언과 동시에 사용하게 되고, 다른곳에서 사용불가// 버튼같은 경우에 눌렀을때 하는 행동이 모두 다 다르기때문에 한개당 ActionListener를 지정받은 클래스를 새로 만들어야 하고 이름을 짓기 힘들어짐.
따라서 그 버튼에서만 쓸 익명 클래스로 구현해서 사용한다.
계속 클래스를 만들어서 버튼을 만들지 말고 , 익명클래스를 사용하자!

★예외처리 Exception Handling) - 프로그램 실행중 오류로인한 중단을 막기 위함
오류 = 에러(error(심각한 오류)) / 예외(exception(덜심각한 오류 (예측및 대비가 가능))
-일부 문법이나 클래스는 사용시 try-catch문이 강제되는 코드가 있다
★ Exception을 디테일하게 써주면 좋다.(협업좋음) / 모든예외클래스들의 상위클래스이다.
Exception e
e.printStackTrace(); 예외관련 메세지를 콘솔에 출력
e.getMessage(); 예외 관련 메세지를 String 타입으로 리턴
사용법 = try{오류날 문장;}catch(예외클래스명1 예외객체명1){오류날때 실행할 문장;}catch(예외클래스명2 예외객체명2){오류때 실행할 문장;}finally{예외발생상관없이 무조건 실행할 문장;}
Exception 클래스를 상속받아서 나만의 예외를 만들수 있음.
throw : 임의로 예외를 발생 시키기 위해서 사용. (원래는 오류가 아닌데 나는 이 케이스를 오류로 처리하고 싶음!) // throw 내가만든예외객체명; new 내가만든예외클래스명();
메소드에서는 소괄호 뒤에 throws로 던져준다.  ex > public static void main(String[] args) throws Exception
★최상단 메소드를 제외한 나머지 메소드에서 예외처리는 반드시 throws 

API (Application Programming Interface) 응용프로그램을 개발할때 필요한 라이브러리들이 모여있는 집합
선배개발자들이 JAVA에서 코딩을 쉽게 할 수 있도록 만들어 놓은것 
JAVA API(내부라입러리) - Oracle
java.lang :자바프로그래밍을 위한 가장 기본적인 패키지
java.util : 데이터를 효율적으로 지정하기 위한 패키지
java.io : 키보드 모니터 









